Conditions:
  IsProdCondition:
    Fn::Equals:
      - ${sls:stage}
      - prod

Resources:
  # ECS Cluster
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: ${self:service}-${self:provider.stage}-cluster
      ClusterSettings:
        - Name: containerInsights
          Value: enabled

  # Redis Cluster
  # RedisCluster:
  #   Type: AWS::ElastiCache::CacheCluster
  #   Properties:
  #     CacheNodeType: cache.t3.micro
  #     Engine: redis
  #     NumCacheNodes: 1
  #     VpcSecurityGroupIds:
  #       - !Ref RedisSecurityGroup
  #     CacheSubnetGroupName: !Ref RedisSubnetGroup
  #     ClusterName: ${self:service}-${self:provider.stage}-redis
  #     Tags:
  #       - Key: Name
  #         Value: ${self:service}-${self:provider.stage}-redis

  # RedisSecurityGroup:
  #   Type: AWS::EC2::SecurityGroup
  #   Properties:
  #     GroupDescription: 'Security group for Redis allowing access from ECS tasks'
  #     VpcId: !Ref vwanuVPC
  #     SecurityGroupIngress:
  #       - IpProtocol: tcp
  #         FromPort: 6379
  #         ToPort: 6379
  #         SourceSecurityGroupId: !Ref ECSTaskSecurityGroup
  #     SecurityGroupEgress:
  #       - IpProtocol: -1
  #         FromPort: -1
  #         ToPort: -1
  #         CidrIp: 0.0.0.0/0
  #     Tags:
  #       - Key: Name
  #         Value: ${self:service}-${self:provider.stage}-redis-sg

  # RedisSubnetGroup:
  #   Type: AWS::ElastiCache::SubnetGroup
  #   Properties:
  #     Description: 'Subnet group for Redis in ${self:service}-${self:provider.stage}'
  #     SubnetIds:
  #       - !Ref PrivateSubnet1
  #       - !Ref PrivateSubnet2

  # Task Definition
  ECSTaskDefinitionHttpServer:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: ${self:service}-${self:provider.stage}-http-server-task
      Cpu: '256'
      Memory: '512'
      RuntimePlatform:
        CpuArchitecture: ARM64
        OperatingSystemFamily: LINUX
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn:
        Fn::GetAtt: [ECSTaskExecutionRole, Arn]
      ContainerDefinitions:
        - Name: http-server
          Image:
            Fn::Join:
              - ''
              - - ${self:custom.ecr.repositoryUri}
                - ':'
                - ${self:custom.ecr.imageTag}
          PortMappings:
            - ContainerPort: 4000
              Protocol: tcp
          Essential: true
          Environment: ${file(resources/ecs/environment.yml)}
          # LogConfiguration:
          #   LogDriver: awslogs
          #   Options:
          #     awslogs-group: /ecs/${self:service}-${self:provider.stage}
          #     awslogs-region: ${self:provider.region}
          #     awslogs-stream-prefix: ecs

  # Task Definition
  # ECSTaskDefinitionWebSocketServer:
  #   Type: AWS::ECS::TaskDefinition
  #   Properties:
  #     Family: ${self:service}-${self:provider.stage}-ws-server-task
  #     Cpu:
  #       Fn::If:
  #         - IsProdCondition
  #         - '1024'
  #         - '512'
  #     Memory:
  #       Fn::If:
  #         - IsProdCondition
  #         - '2048'
  #         - '1024'
  #     RuntimePlatform:
  #       CpuArchitecture: ARM64
  #       OperatingSystemFamily: LINUX
  #     NetworkMode: awsvpc
  #     RequiresCompatibilities:
  #       - FARGATE
  #     ExecutionRoleArn:
  #       Fn::GetAtt: [ECSTaskExecutionRole, Arn]
  #     TaskRoleArn:
  #       Fn::GetAtt: [ECSTaskRole, Arn]
  #     ContainerDefinitions:
  #       - Name: ws-server
  #         Image:
  #           Fn::Join:
  #             - ''
  #             - - ${self:custom.ecr.repositoryUri}
  #               - ':'
  #               - ${self:custom.ecr.imageTag}
  #         PortMappings:
  #           - ContainerPort: 4000
  #             Protocol: tcp
  #         Essential: true
  #         # TODO: Add the environment variables
  #         Environment: ${file(resources/ecs/environment.yml)}
  #         LogConfiguration:
  #           LogDriver: awslogs
  #           Options:
  #             awslogs-group: /ecs/${self:service}-${self:provider.stage}
  #             awslogs-region: ${self:provider.region}
  #             awslogs-stream-prefix: ecs

  # ECS Service
  HttpServerECSService:
    Type: AWS::ECS::Service
    Properties:
      ServiceName: ${self:service}-${self:provider.stage}-http-server-service
      Cluster:
        Ref: ECSCluster
      LaunchType: FARGATE
      DesiredCount: 1
      TaskDefinition:
        Ref: ECSTaskDefinitionHttpServer
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          Subnets:
            - subnet-03bc2568cd15ed673
          SecurityGroups:
            - Ref: ECSTaskSecurityGroup
      DeploymentConfiguration:
        DeploymentCircuitBreaker:
          Enable: true
          Rollback: true
        MaximumPercent: 200
        MinimumHealthyPercent: 50

  # WebSocketServerECSService:
  #   Type: AWS::ECS::Service
  #   DependsOn: ApplicationLoadBalancerListener
  #   Properties:
  #     ServiceName: ${self:service}-${self:provider.stage}-ws-server-service
  #     Cluster:
  #       Ref: ECSCluster
  #     LaunchType: FARGATE
  #     DesiredCount: 2 # TODO: After testing adjust the desired number of tasks, we probably want to start with 2 in staging and production
  #     TaskDefinition:
  #       Ref: ECSTaskDefinitionWebSocketServer
  #     NetworkConfiguration:
  #       AwsvpcConfiguration:
  #         AssignPublicIp: DISABLED
  #         Subnets:
  #           - Ref: PrivateSubnet1
  #           - Ref: PrivateSubnet2
  #         SecurityGroups:
  #           - Ref: ECSTaskSecurityGroup
  #     LoadBalancers:
  #       - TargetGroupArn:
  #           Ref: WebSocketTargetGroup
  #         ContainerName: ws-server
  #         ContainerPort: 4000
  #     DeploymentConfiguration:
  #       DeploymentCircuitBreaker:
  #         Enable: true
  #         Rollback: true
  #       MaximumPercent: 200
  #       MinimumHealthyPercent: 50

  # Application Load Balancer
  # ApplicationLoadBalancer:
  #   Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  #   Properties:
  #     Name: ${self:custom.shortServiceName}-${self:provider.stage}-alb
  #     Scheme: internet-facing
  #     Subnets:
  #       - Ref: PublicSubnet1
  #       - Ref: PublicSubnet2
  #     SecurityGroups:
  #       - Ref: ALBSecurityGroup
  #     Type: application

  # ALB Security Group
  # ALBSecurityGroup:
  #   Type: AWS::EC2::SecurityGroup
  #   Properties:
  #     GroupDescription: Security group for ALB
  #     VpcId:
  #       Fn::ImportValue: DefaultVPCId
  #     SecurityGroupIngress:
  #       - IpProtocol: tcp
  #         FromPort: 443
  #         ToPort: 443
  #         CidrIp: 0.0.0.0/0 # Allow inbound HTTPS traffic from anywhere
  #     SecurityGroupEgress:
  #       - IpProtocol: -1
  #         FromPort: -1
  #         ToPort: -1
  #         CidrIp: 0.0.0.0/0 # Allow all outbound traffic
  #     Tags:
  #       - Key: Name
  #         Value: ${self:service}-${self:provider.stage}-alb-sg

  # ECS Task Security Group
  ECSTaskSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for ECS tasks
      VpcId:
        Fn::ImportValue: DefaultVPCId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 4000
          ToPort: 4000
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0

  # Target Groups
  # HttpTargetGroup:
  #   Type: AWS::ElasticLoadBalancingV2::TargetGroup
  #   Properties:
  #     Name: ${self:custom.shortServiceName}-${self:provider.stage}-http
  #     Port: 4000
  #     Protocol: HTTP
  #     VpcId:
  #       Ref: VwanuVPC
  #     TargetType: ip
  #     HealthCheckIntervalSeconds: 30
  #     HealthCheckProtocol: HTTP
  #     HealthCheckPath: /health
  #     Matcher:
  #       HttpCode: '200'
  #     Tags:
  #       - Key: Name
  #         Value: ${self:service}-${self:provider.stage}-http-tg

  # WebSocketTargetGroup:
  #   Type: AWS::ElasticLoadBalancingV2::TargetGroup
  #   Properties:
  #     Name: ${self:custom.shortServiceName}-${self:provider.stage}-ws
  #     Port: 4000
  #     Protocol: HTTP
  #     VpcId:
  #       Ref: VwanuVPC
  #     TargetType: ip
  #     HealthCheckIntervalSeconds: 30
  #     HealthCheckProtocol: HTTP
  #     HealthCheckPath: /health
  #     Matcher:
  #       HttpCode: '200'
  #     Tags:
  #       - Key: Name
  #         Value: ${self:service}-${self:provider.stage}-ws-tg

  # ALB Listener
  # ApplicationLoadBalancerListener:
  #   Type: AWS::ElasticLoadBalancingV2::Listener
  #   Properties:
  #     LoadBalancerArn:
  #       Ref: ApplicationLoadBalancer
  #     Port: 443
  #     Protocol: HTTPS
  #     Certificates:
  #       - CertificateArn:
  #           Ref: ApiLoadBalancerCertificate
  #     SslPolicy: ELBSecurityPolicy-TLS-1-2-2017-01 # or choose a more recent policy if available
  #     DefaultActions:
  #       - Type: forward
  #         TargetGroupArn:
  #           Ref: HttpTargetGroup

  # WebSocketListenerRule:
  #   Type: 'AWS::ElasticLoadBalancingV2::ListenerRule'
  #   Properties:
  #     Conditions:
  #       - Field: path-pattern
  #         Values:
  #           - '/subscriptions*'
  #     Actions:
  #       - Type: forward
  #         TargetGroupArn:
  #           Ref: WebSocketTargetGroup
  #     ListenerArn:
  #       Ref: ApplicationLoadBalancerListener
  #     Priority: 1

  # IAM Roles
  ECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: ${self:service}-${self:provider.stage}-ecs-execution-role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy

  ECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: ${self:service}-${self:provider.stage}-ecs-task-role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonRDSFullAccess  # Permissive for testing
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy  # For basic ECS functionality

  # CloudWatch Logs Log Group (commented out for minimal setup)
  # ECSLogGroup:
  #   Type: AWS::Logs::LogGroup
  #   Properties:
  #     LogGroupName: /ecs/${self:service}-${self:provider.stage}
  #     RetentionInDays: 14
  #     Tags:
  #       - Key: Name
  #         Value: ${self:service}-${self:provider.stage}-log-group

  # Domain setup (commented out - will use default Fargate URL)
  # ApiRecordSet:
  #   Type: AWS::Route53::RecordSet
  #   Properties:
  #     HostedZoneId: ${ssm:/${sls:stage}/hostedZoneId}
  #     Name: api.${self:provider.stage}.wadsonvaval.click
  #     Type: A
  #     AliasTarget:
  #       DNSName:
  #         Fn::GetAtt: [ApplicationLoadBalancer, DNSName]
  #       HostedZoneId:
  #         Fn::GetAtt: [ApplicationLoadBalancer, CanonicalHostedZoneID]
  #       EvaluateTargetHealth: false

  # SSL Certificate (commented out - not needed for basic setup)
  # ApiLoadBalancerCertificate:
  #   Type: 'AWS::CertificateManager::Certificate'
  #   Properties:
  #     DomainName: api.${self:provider.stage}.wadsonvaval.click
  #     ValidationMethod: DNS
  #     DomainValidationOptions:
  #       - DomainName: api.${self:provider.stage}.wadsonvaval.click
  #         HostedZoneId: ${ssm:/${sls:stage}/hostedZoneId}

  # Auto Restart Mechanism (commented out for minimal setup)
  # TaskRestartLambdaRole:
  #   Type: AWS::IAM::Role
  #   Properties:
  #     AssumeRolePolicyDocument:
  #       Version: '2012-10-17'
  #       Statement:
  #         - Effect: Allow
  #           Principal:
  #             Service: lambda.amazonaws.com
  #           Action: sts:AssumeRole
  #     Policies:
  #       - PolicyName: ECSTaskRestartPolicy
  #         PolicyDocument:
  #           Version: '2012-10-17'
  #           Statement:
  #             - Effect: Allow
  #               Action:
  #                 - ecs:UpdateService
  #                 - ecs:DescribeServices
  #               Resource:
  #                 - !Ref HttpServerECSService
  #             - Effect: Allow
  #               Action:
  #                 - logs:CreateLogGroup
  #                 - logs:CreateLogStream
  #                 - logs:PutLogEvents
  #               Resource: '*'

  # Lambda Function to Force Redeployment (commented out for minimal setup)
  # TaskRestartLambda:
  #   Type: AWS::Lambda::Function
  #   Properties:
  #     Handler: index.lambda_handler
  #     Runtime: python3.8
  #     Role: !GetAtt TaskRestartLambdaRole.Arn
  #     Code:
  #       ZipFile: |
  #         import boto3
  #         import os
  #         import json

  #         def lambda_handler(event, context):
  #             print("Event received:", json.dumps(event))
  #             ecs = boto3.client('ecs')
  #             cluster = os.environ['CLUSTER_NAME']
  #             http_service = os.environ['HTTP_SERVICE_NAME']
              
  #             print(f"Forcing redeployment for service {http_service} in cluster {cluster}")
              
  #             try:
  #                 # Force a new deployment
  #                 response = ecs.update_service(
  #                     cluster=cluster,
  #                     service=http_service,
  #                     forceNewDeployment=True
  #                 )
  #                 return {
  #                     'statusCode': 200,
  #                     'body': f"Forced redeployment of ECS service {http_service}"
  #                 }
  #             except Exception as e:
  #                 print(f"Error: {str(e)}")
  #                 raise e
  #     Environment:
  #       Variables:
  #         CLUSTER_NAME: !Ref ECSCluster
  #         HTTP_SERVICE_NAME: !GetAtt HttpServerECSService.Name
  #     Timeout: 30

  # Lambda Permissions (commented out for minimal setup)
  # TaskRestartLambdaPermission:
  #   Type: AWS::Lambda::Permission
  #   Properties:
  #     FunctionName: !Ref TaskRestartLambda
  #     Action: lambda:InvokeFunction
  #     Principal: lambda.alarms.cloudwatch.amazonaws.com
  #     SourceArn: !GetAtt High5xxErrorAlarm.Arn

  # TaskRestartLambdaPermissionCpu:
  #   Type: AWS::Lambda::Permission
  #   Properties:
  #     FunctionName: !Ref TaskRestartLambda
  #     Action: lambda:InvokeFunction
  #     Principal: lambda.alarms.cloudwatch.amazonaws.com
  #     SourceArn: !GetAtt HighCpuTaskRestartAlarm.Arn

  # Add permission for the WebSocket CPU Alarm too
  # TaskRestartLambdaPermissionWebSocketCpu:
  #   Type: AWS::Lambda::Permission
  #   Properties:
  #     FunctionName: !Ref TaskRestartLambda
  #     Action: lambda:InvokeFunction
  #     Principal: lambda.alarms.cloudwatch.amazonaws.com
  #     SourceArn: !GetAtt WebSocketHighCpuTaskRestartAlarm.Arn

  # CloudWatch Alarm for HTTP 5XX Errors
  # High5xxErrorAlarm:
  #   Type: AWS::CloudWatch::Alarm
  #   Properties:
  #     AlarmName: !Sub '${AWS::StackName}-High504-RestartTasks'
  #     AlarmDescription: 'Trigger Lambda to restart ECS tasks when ALB 504 Gateway Timeout errors exceed threshold'
  #     Namespace: AWS/ApplicationELB
  #     MetricName: HTTPCode_ELB_504_Count
  #     Dimensions:
  #       - Name: LoadBalancer
  #         Value:
  #           Fn::Sub:
  #             - 'app/${LoadBalancerName}/${LoadBalancerId}'
  #             - LoadBalancerName: !GetAtt ApplicationLoadBalancer.Name
  #               LoadBalancerId:
  #                 !Select [
  #                   3,
  #                   !Split [
  #                     '/',
  #                     !GetAtt ApplicationLoadBalancer.LoadBalancerArn,
  #                   ],
  #                 ]
  #     Statistic: Sum
  #     Period: 300
  #     EvaluationPeriods: 1
  #     Threshold: 10
  #     ComparisonOperator: GreaterThanOrEqualToThreshold
  #     AlarmActions:
  #       - !GetAtt TaskRestartLambda.Arn
  #     TreatMissingData: notBreaching

  # CloudWatch Alarm to Trigger on High CPU for HTTP Server
  # HighCpuTaskRestartAlarm:
  #   Type: AWS::CloudWatch::Alarm
  #   Properties:
  #     AlarmName: !Sub '${AWS::StackName}-HTTP-HighCPU-RestartTasks'
  #     AlarmDescription: 'Trigger Lambda to restart HTTP tasks when CPU > 75%'
  #     Namespace: AWS/ECS
  #     MetricName: CPUUtilization
  #     Dimensions:
  #       - Name: ClusterName
  #         Value: !Ref ECSCluster
  #       - Name: ServiceName
  #         Value: !GetAtt HttpServerECSService.Name
  #     Statistic: Average
  #     Period: 60
  #     EvaluationPeriods: 1
  #     Threshold: 75
  #     ComparisonOperator: GreaterThanThreshold
  #     AlarmActions:
  #       - !GetAtt TaskRestartLambda.Arn

  # CloudWatch Alarm to Trigger on High CPU for WebSocket Server
  # WebSocketHighCpuTaskRestartAlarm:
  #   Type: AWS::CloudWatch::Alarm
  #   Properties:
  #     AlarmName: !Sub '${AWS::StackName}-WS-HighCPU-RestartTasks'
  #     AlarmDescription: 'Trigger Lambda to restart WebSocket tasks when CPU > 75%'
  #     Namespace: AWS/ECS
  #     MetricName: CPUUtilization
  #     Dimensions:
  #       - Name: ClusterName
  #         Value: !Ref ECSCluster
  #       - Name: ServiceName
  #         Value: !GetAtt WebSocketServerECSService.Name
  #     Statistic: Average
  #     Period: 60
  #     EvaluationPeriods: 1
  #     Threshold: 75
  #     ComparisonOperator: GreaterThanThreshold
  #     AlarmActions:
  #       - !GetAtt TaskRestartLambda.Arn

  # Auto Scaling
  # ECSAutoScalingRole:
  #   Type: AWS::IAM::Role
  #   Properties:
  #     RoleName: ${self:service}-${self:provider.stage}-ecs-autoscaling-role
  #     AssumeRolePolicyDocument:
  #       Version: '2012-10-17'
  #       Statement:
  #         - Effect: Allow
  #           Principal:
  #             Service: application-autoscaling.amazonaws.com
  #           Action: 'sts:AssumeRole'
  #     ManagedPolicyArns:
  #       - arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceAutoscaleRole
  #     Description: 'Role for ECS Application Auto Scaling'

  # HTTP Server Auto Scaling
  # HttpServerScalableTarget:
  #   Type: AWS::ApplicationAutoScaling::ScalableTarget
  #   DependsOn: HttpServerECSService
  #   Properties:
  #     MaxCapacity: 4
  #     MinCapacity: 2
  #     ResourceId: !Sub 'service/${ECSCluster.Name}/${HttpServerECSService.Name}'
  #     ScalableDimension: ecs:service:DesiredCount
  #     ServiceNamespace: ecs
  #     RoleARN: !GetAtt ECSAutoScalingRole.Arn

  # HttpServerScalingPolicy:
  #   Type: AWS::ApplicationAutoScaling::ScalingPolicy
  #   DependsOn: HttpServerScalableTarget
  #   Properties:
  #     PolicyName: ecs-auto-scaling-policy-${self:provider.stage}
  #     PolicyType: TargetTrackingScaling
  #     ScalingTargetId: !Ref HttpServerScalableTarget
  #     TargetTrackingScalingPolicyConfiguration:
  #       TargetValue: 75.0 # 75% CPU utilization
  #       PredefinedMetricSpecification:
  #         PredefinedMetricType: ECSServiceAverageCPUUtilization
  #       ScaleInCooldown: 300
  #       ScaleOutCooldown: 300
  #       DisableScaleIn: false

  # WebSocket Server Auto Scaling
  # WebSocketServerScalableTarget:
  #   Type: AWS::ApplicationAutoScaling::ScalableTarget
  #   Properties:
  #     MaxCapacity: 4
  #     MinCapacity: 2
  #     ResourceId: !Sub 'service/${self:service}-${self:provider.stage}-cluster/${self:service}-${self:provider.stage}-ws-server-service'
  #     ScalableDimension: ecs:service:DesiredCount
  #     ServiceNamespace: ecs
  #     RoleARN: !GetAtt ECSAutoScalingRole.Arn

  # WebSocketServerScalingPolicy:
  #   Type: AWS::ApplicationAutoScaling::ScalingPolicy
  #   Properties:
  #     PolicyName: ws-auto-scaling-policy-${self:provider.stage}
  #     PolicyType: TargetTrackingScaling
  #     ScalingTargetId: !Ref WebSocketServerScalableTarget
  #     TargetTrackingScalingPolicyConfiguration:
  #       TargetValue: 70.0 # 70% CPU utilization
  #       PredefinedMetricSpecification:
  #         PredefinedMetricType: ECSServiceAverageCPUUtilization
  #       ScaleInCooldown: 300
  #       ScaleOutCooldown: 60
  #       DisableScaleIn: false

  # Comment out subnet creation - using existing default VPC subnet instead
  # DefaultSubnet1:
  #   Type: AWS::EC2::Subnet
  #   Properties:
  #     VpcId: 
  #       Fn::ImportValue: DefaultVPCId
  #     AvailabilityZone: ${self:provider.region}a
  #     CidrBlock: 10.0.1.0/24
  #     MapPublicIpOnLaunch: true
  #     Tags:
  #       - Key: Name
  #         Value: ${self:service}-${self:provider.stage}-subnet
